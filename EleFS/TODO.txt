* File crypto version - Extend the mirror example
	Salt for filename, in hex, then '_', then hex compressed and encrypted filename
	Use long key, 256 bytes?, based on key plus salt for each file, use file position eor file position shifted based on key size, to use for each byte eor
		Pass-through all reads and writes using byte eor
	Advantages, uses underlying file caching and doesn't have complexities of container file based
	* Test: EleFS2\RunTest.bat
	* File contents encrption works: EleFS2ReadFile and EleFS2WriteFile using EncryptDecryptBuffer
	* TODO: Encrypt file and directory names
		Filename is going to need salt
		EleFS2FindFiles
		Perhaps a good place to start would be applying crypto to the path calculated by: GetFilePath ?
			Be careful of UNC network paths?
			Might need to validate each part is a file or directory?
		FillFindData -> findData.cFileName contains "." or ".." or a single filename or directory name, perfect for de-encrypting and getting a salt value from
			Perhaps _DOKAN_FILE_INFO->Context can be used for the salt found in the filename?
				Darn, it looks like it is used "->Context" for the real file handle
			Plan B, means GetFilePath will need to do some scanning of files, decrypt them, file the right information and salt
				This is because a salted filename will constantly change and needs intensive scanning to find
					Which would be slow
				Could use an internal cache of the path?









* Striped crypto mode. Block size is multiplied by stripes. Offset within stripe. Blocks filled with random data.
	Extent not reduced of course. New blocks will have to extend.
	Obvious place would be to add this functionality to FileCrypto
		This would need to include file pointer massaging hooks for:
			SetFilePointerEx
			SetEndOfFile
			GetFileSizeEx
		These would need to accept/return suitable values based on the stripe settings.




* Enabling encryption causes corruption? Investigate why.
	Or does corruption happen without encryption, but just less often?




* Might want to use CommutativeEncryptBytewise() for byte wise support instead of the 32 bit chunked crypto?




* Expand the tests so that a new file system is mounted
	* Files copied into it from multiple processes (use bat files)
	* The resultant files verified
	* Unmounted
	* Remounted
	* The resultant files verified again




* Implement storage of extra file information as a generic text field in EleFS. This is to be used for file security tokens.




* Implement MirrorSetFileSecurity/MirrorGetFileSecurity using the file generic text field.
	The root of the file system, when queried, can use the file's security token.
	Remember to add the option FILE_PERSISTENT_ACLS




* // MPi: TODO: Handle the corrupt block



* // MPi: TODO: Look for a better alternative to ERROR_NO_MORE_ITEMS
